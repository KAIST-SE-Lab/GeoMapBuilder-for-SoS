package kr.ac.kaist.se.model.sos;

import kr.ac.kaist.se.data.SimLogEvent;
import kr.ac.kaist.se.model.abst.cap._SimAction_;
import kr.ac.kaist.se.model.abst.obj._SimObject_;
import kr.ac.kaist.se.model.sos.cap.MoveAction;

import java.util.ArrayList;

/**
 * Abstract class to represent an object who can move around SoSMap
 *
 * An Entity class is defined as an actionable object (which can perform its own action(s))
 * (note: independent from SIMVA-SoS Lite)
 *
 * @author ymbaek, ehcho, yjshin
 */
public abstract class Entity extends _SimObject_ {

    //SoS that this object belongs to
    protected SoS mySoS;

    /* ArrayLists to store _SimAction_ objects */
    protected ArrayList<_SimAction_> capableActionList = new ArrayList<>();     //List of capable actions
    protected ArrayList<_SimAction_> selectedActionList = new ArrayList<>();    //List of selected actions for execution of a particular tick


    public Entity(SoS mySoS,
                  String id,
                  String name) {
        super(id, name);
        this.mySoS = mySoS;

        //Initialization of object location
        initObjLocation();

        //Initialization of actions
        initCapableActions();
    }

    public Entity(SoS mySoS,
                  String id,
                  String name,
                  String objLocation) {
        super(id, name, objLocation);
        this.mySoS = mySoS;

        //Initialization of object location
        initObjLocation();

        //Initialization of actions
        initCapableActions();
    }


    /*
        Note that if you implement run(..) method here,
        all the instantiated Entity objects have same run(..) methods.
        (i.e., All entities have same capabilities and behaviors.)
         */
    @Override
    public ArrayList<SimLogEvent> run(int tick) {

        //List of SimLogEvents generated by running actions
        ArrayList<SimLogEvent> logEventList = new ArrayList<>();

        //Clear existing selectedActionList (from previous tick)
        clearSelectedActionList();

        //Select actions to execute
        selectActions();

        for (_SimAction_ aAction : selectedActionList){
            if (aAction instanceof MoveAction){
                ((MoveAction) aAction).printMoveActionInfo();
            }
        }

        for (_SimAction_ action : selectedActionList){
            ArrayList<SimLogEvent> actionRunLog = doAction(action, tick);

            if (actionRunLog != null) {
                logEventList.addAll(actionRunLog);
            }
        }

        return logEventList;
    }


    private ArrayList<SimLogEvent> doAction(_SimAction_ actionObj, int tick){

        ArrayList<SimLogEvent> actionLogEvents = new ArrayList<>();

        //This project only considers MoveAction.
        //However, original class (_SimActionableObject_) can perform:
        //(1)FuncAction, (2)MoveAction, and (3)CommAction
        if (actionObj instanceof MoveAction){
            actionLogEvents = actionObj.executeAction(tick);
        }

        return actionLogEvents;
    }


    /**
     * Select an action(s) and store into selectedActionList
     */
    protected void selectActions() {

        //A list to store possible move actions
        ArrayList<_SimAction_> possibleMoveActions = new ArrayList<>();
        //A list to store selected move actions
        ArrayList<_SimAction_> selectedMoveActions = new ArrayList<>();

        for (_SimAction_ aAction : capableActionList){
            if (aAction instanceof MoveAction){
                possibleMoveActions.add(aAction);
            }
        }


        //If there is a set of selected move actions
        if (possibleMoveActions.size() > 0){
            selectedMoveActions = selectMoveActions(possibleMoveActions);
            if (selectedMoveActions != null) {
                selectedActionList.addAll(selectMoveActions(possibleMoveActions));
            }
        }
    }


    /**
     * Initialization of actions
     */
    protected abstract void initCapableActions();


    /**
     * Select a move action(s) among possible move actions.
     * A proper mechanism to select move actions should be implemented in a movable object.
     * (This method is originally implemented in 'Movable' interface)
     *
     * @param possibleMoveActions MoveActions that can be executed
     * @return List of selected move actions
     */
    protected abstract ArrayList<_SimAction_> selectMoveActions(ArrayList<_SimAction_> possibleMoveActions);


    /* Getters & Setters */

    public ArrayList<_SimAction_> getCapableActionList() {
        return capableActionList;
    }

    public void setCapableActionList(ArrayList<_SimAction_> capableActionList) {
        this.capableActionList = capableActionList;
    }

    public void addCapableAction(_SimAction_ aAction){
        if (aAction != null){
            this.capableActionList.add(aAction);
        }
    }

    private void clearSelectedActionList() {
        selectedActionList.clear();
    }

    public SoS getMySoS() {
        return mySoS;
    }

    public void setMySoS(SoS mySoS) {
        this.mySoS = mySoS;
    }
}
